# 笔记
## 定义
- 元编程：编写能在运行时操作语言构件的代码，也就是能写代码的代码。
- 动态元编程：编写在运行时操作自身的代码；（本书类型）
- 静态元编程：代码生成器和编译器生成的代码；
- 对象：一组实例变量外加一个指向其类的引用；对象的方法并不存在于对象本身，而是存在于对象的类中；在类中，这些方法被成为类的实例方法；
- 类：一个对象（class类的一个实例）外加一组实例方法和一个对超类的引用；Class 类是Module 类的子类，因此一个类也是一个模块；类的名字只是一个常量；
- 祖先链：ancestors chain
- 白板类：Blank Slate，它用于的方法比 Object类还要少；BasicObject类就是白板类；
- 代码块：block，也叫做闭包(closure)，代码块可以获取局部绑定，并一直带着它们。
- 作用域：scope
- 作用域门：Scope Gate，每当程序进入（或离开）类定义、模块定义、方法时，就会发生作用域切换。分别以class、module、def关键字作为标志，每个关键字都对应一个作用域门。
- 扁平作用域：Flat Scope，如果两个作用域挤压在一起，它们就可以共享格子的变量；
- 块对象：Proc，是由块转换来的对象；
- 领域专属语言：DSL
- 单件方法：Singleton Method，只对单个对象生效的方法；
- 类宏：Class Macro，类似 attr_accessor这样的方法，看起来很像关键字，但是只是普通的方法，只不过可以用在类定义里。

## 启迪
- Ruby对象模型中，类本身也是对象。一个类的方法就是class的实例方法；
Array >> Object >> BasicObject
- Class 类的超类是 Module(模块)，即每一个类都是一个模块。
p Class.superclass     # => Module
- 如果你希望把自己的代码包含（include）到别的代码中，就应该使用模块；如果你希望某段代码被实例化或者被继承，就应该使用类。
- Kernel (核心)模块 包含在Object类中，进而进入到每个对象到祖先链，于是无论那个对象都可以随意调用Kernel 模块的方法，如print等；
- 私有方法服从的规则：1、不能明确指定接收者来调用私有方法，即私有方法只能通过隐性的接收者self调用；2、如果调用方法的接收者不是自己，就必须明确指明接收者；
- 在可以使用动态方法的时候，尽量使用动态方法；除非必须使用幽灵方法，否则尽量不要使用它。
- Ruby 没有嵌套式的作用域，它的作用域是截然分开的：一旦进入一个新的作用域，原先的绑定会被替换为一组新的绑定。
- 程序会在三个地方关闭前一个作用域，同时打开一个新的作用域：类定义，模块定义，方法；
- 类方法的实质是：它是一个类的单件方法。

## 技巧
- Kernel Method 内核方法，给Kernel 模块增加一个方法，这个方法就对所以对象可用了；
- 细化就像在原来的类上添加类一块补丁，而且它会覆盖正常的方法查找。此外，细化只在程序的部分区域生效：从using语句的位置开始，直到模块结束，或者直到文件结束。
- 被method_missing 方法处理的消息，从调用者角度来看，跟普通方法没什么区别，而实际上接收者并没有对应的方法，这称为**幽灵方法**(Ghost Method)
- 删除方法：两种方法，Module#undef_method(比较蛮横，会删除包括继承而来的所有方法) 和 Module#remove_method(比较温柔，只删除接收者自己的方法，而保留继承来的方法);
- 用 Module#attr_* 方法定义访问器。Module#attr_reader 可以生成读方法，Module#attr_writer 可以生成写方法，而Module#attr_accessor 可以同时生成两者；
- alias_method 方法相当于复制并重命名一个方法，而不改变原方法；
- 钩子方法（Hook Method），提供了一种方式用于在程序运行时扩展程序的行为。


### lambda与proc的区别
- 用lambda 方法创建的Proc 称为lambda，用其他方式创建的称为proc，可以用Proc#lambda? 方法检测Proc是不是lambda；
- 在参数问题上，lambda 的适应能力比proc差；如果调用lambda时的参数数量不对，就会抛出ArgumentError错误，而proc则会把传来的参数调整成自己期望的参数形式；
- 整体而言，lambda更直观，更像一个方法，对参数数量要求严格，在调用return时确实只是从代码中返回。

### Ruby对象模型的七条规则
- 只有一种对象————要么是普通对象，要么是模块；
- 只有一种模块————要么是一个普通模块、一个类或者一个单件类；
- 只有一种方法，它存在于一个模块中————通常是在一个类中；
- 每个对象（包括类）都有自己“真正的类”————要么是一个普通类，要么是一个单件类；
- 除了 BasicObject 类没有超类外，每个类有且只有一个祖先————要么是一个类，要么是一个模块。这意味着任何类只有一条向上的、直到 BasicObject 的祖先链；
- 一个对象的单件类的超类是这个对象的类；一个类的单件类的超类是这个类的超类的单件类。（P124图）
- 调用一个方法是，Ruby先向右迈一步进入接收者真正的类，让后向上进入祖先链。这就是Ruby 查找方法的方式；

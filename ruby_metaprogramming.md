# 笔记
## 定义
- 元编程：编写能在运行时操作语言构件的代码，也就是能写代码的代码。
- 动态元编程：编写在运行时操作自身的代码；（本书类型）
- 静态元编程：代码生成器和编译器生成的代码；
- 对象：一组实例变量外加一个指向其类的引用；对象的方法并不存在于对象本身，而是存在于对象的类中；在类中，这些方法被成为类的实例方法；
- 类：一个对象（class类的一个实例）外加一组实例方法和一个对超类的引用；Class 类是Module 类的子类，因此一个类也是一个模块；类的名字只是一个常量；
- 祖先链：ancestors chain
- 白板类：Blank Slate，它用于的方法比 Object类还要少；BasicObject类就是白板类；
- 代码块：block，也叫做闭包(closure)，代码块可以获取局部绑定，并一直带着它们。
- 作用域：scope

## 启迪
- Ruby对象模型中，类本身也是对象。一个类的方法就是class的实例方法；
Array >> Object >> BasicObject
- Class 类的超类是 Module(模块)，即每一个类都是一个模块。
p Class.superclass     # => Module
- 如果你希望把自己的代码包含（include）到别的代码中，就应该使用模块；如果你希望某段代码被实例化或者被继承，就应该使用类。
- Kernel (核心)模块 包含在Object类中，进而进入到每个对象到祖先链，于是无论那个对象都可以随意调用Kernel 模块的方法，如print等；
- 私有方法服从的规则：1、不能明确指定接收者来调用私有方法，即私有方法只能通过隐性的接收者self调用；2、如果调用方法的接收者不是自己，就必须明确指明接收者；
- 在可以使用动态方法的时候，尽量使用动态方法；除非必须使用幽灵方法，否则尽量不要使用它。
- Ruby 没有嵌套式的作用域，它的作用域是截然分开的：一旦进入一个新的作用域，原先的绑定会被替换为一组新的绑定。

## 技巧
- Kernel Method 内核方法，给Kernel 模块增加一个方法，这个方法就对所以对象可用了；
- 细化就像在原来的类上添加类一块补丁，而且它会覆盖正常的方法查找。此外，细化只在程序的部分区域生效：从using语句的位置开始，直到模块结束，或者直到文件结束。
- 被method_missing 方法处理的消息，从调用者角度来看，跟普通方法没什么区别，而实际上接收者并没有对应的方法，这称为**幽灵方法**(Ghost Method)
- 删除方法：两种方法，Module#undef_method(比较蛮横，会删除包括继承而来的所有方法) 和 Module#remove_method(比较温柔，只删除接收者自己的方法，而保留继承来的方法);
